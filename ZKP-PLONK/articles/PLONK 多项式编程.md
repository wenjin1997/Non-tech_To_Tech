在上篇文章里，我们提到，如果要实现协议验证的过程，Prover 在开始的时候通过多项式编码的方式对 $W$ 表格的每一列进行编码，然后将编码后的结果发给 Verifier 去验证；通过进一步的交互，可以验证等式

$$
q_{L}(X) \cdot w_{a}(X) + q_{R}(X) \cdot w_{b}(X) + q_{M}(X)\cdot(w_{a}(X)\cdot w_{b}(X)) + q_{C}(X) -  q_{O}(X)\cdot w_{c}(X) \overset{?}{=} 0
$$

是否成立。

这是仅在 Prover 是诚实的情况下，我们去验证一个电路的正确性。但是 Prover 很有可能会作恶，为了预防 Prover 作恶，保证电路的正确性和安全性，并在满足约束的情况下，我们需要再验证 $(\sigma_a(X),\sigma_b(X),\sigma_c(X))$ 与 $(w_a(X),w_b(X),w_c(X))$ 之间的关系。

$(\sigma_a(X),\sigma_b(X),\sigma_c(X))$ 是 Prover 计算的多项式，它们通常表示电路中的输入和中间结果；

$(w_a(X),w_b(X),w_c(X))$ 是预先定义的权重多项式，它们表示电路的结构。

简单来说，其实整个验证的过程最终就是把电路的正确性检查转换成一组加法/乘法的多项式约束。

为什么要这样的做呢？当然是提高效率，降低成本。

首先，

我们以第一章里的矩阵 $W$ 的表格形式（表1）为例，它遵循纵向编码的原则，也就是说每一列都可以用一个多项式去表示这一列下的内容计算规则。

目前只有三列，所以即便是逐行检查也不需要花太多时间，但是一旦行数增多到 100 行，那么一行行检查就特别耗费精力，Verifier 需要很强的算力。

因此，可以用一个/若干的多项式去编码三列，把 3*100 的表，变成 3 个多项式来表示。（这点可以结合 excel 表格计算公式来理解，很类似）

![表1](/ZKP-PLONK/images/PLONK多项式编程/表1.png)


其次，变成多项式还有一个天生自带的 buff，假设矩阵 $W$ 的表格可以成功地只用多项式来表示，当 Verifier 进行验证的时候，Verifier 并不需要验证所有域上的点，就可以成功验证电路的正确性。

具体来说：

1. 假设电路的约束可以表示成为一个 3*100 的表，每一行代表一个约束条件。
2. 通过多项式编码的方式，将这 3×100 的表压缩成三个多项式 $σa(X),σb(X),σc(X)$。这些多项式可以通过某种方式（例如拉格朗日插值）从原始约束中构造出来。
3. Verifier 只需要检查这三个多项式在某一个随机点 $X=z$ 上是否满足约束条件。具体来说，Verifier 会检查：

$$
\sigma_a(z)⋅\sigma_b(z)=\sigma_c(z)
$$

如果这个等式在随机点 $z$ 上成立，那么可以高度概率地认为 3×100 这个表里的内容在整个域上都是成立的。

我们结合实例再看一遍，看看具体是怎么进行计算的：

![表1](ZKP-PLONK/images/PLONK多项式编程)


还是以 表1 为例，假设目前表格只有 3*3 ，那么表格中给出的插值点 i 及其对应的值如下：

- 插值点：i = 1,2,3
- 对应的值：
    - wa: x5,x1,x3
    - wb: x6,x2,x4
    - wc: out,x5,x6

接下来我们**开始构造拉格朗日基函数**：

对于每个 i，拉格朗日基函数 ${l_i}{(X)}$ 的定义是：

$$
{l_i}{(X)}=\prod_{j\neq i}^{} \frac{X-j}{i-j} 
$$

具体到插值点：i = 1,2,3，我们分别求出 ${l_1}{(X)},{l_2}{(X)},{l_3}{(X)}$，

- 对于 i = 1，

$$
{l_1}{(X)}=\frac{(X-2)(X-3)}{(1-2)(1-3)} =\frac{(X-2)(X-3)}{2} 
$$

- 对于 i = 2，

$$
{l_2}{(X)}=\frac{(X-1)(X-3)}{(2-1)(2-3)} = -(X-1)(X-3)
$$

- 对于 i = 3，

$$
{l_3}{(X)}=\frac{(X-1)(X-2)}{(3-1)(3-2)} =\frac{(X-1)(X-2)}{2} 
$$

接下来，结合 表1 中的内容，和上面已经求出的对应 i 的拉格朗日基函数**，**我们**开始构造插值多项式：**

对于 $w_a$

$$
\sigma_a(X)=x_5 \cdot l_1(X)+x_1 \cdot l_2(X) +x_3 \cdot l_3(X)
$$

代入 ${l_1}(X)$，

$$
\begin{align}
\sigma_a(X) & = x_5 \cdot l_1(X)+x_1 \cdot l_2(X) +x_3 \cdot l_3(X) & \\ &
= x_5 \cdot \frac{(X-2)(X-3)}{2} - x_1 \cdot(X-1)(X-3)+x_3 \cdot\frac{(X-1)(X-2)}{2}
\end{align}
$$

对于 $w_b$

$$
\sigma_b(X)=x_6 \cdot l_1(X)+x_2 \cdot l_2(X) +x_4 \cdot l_3(X)
$$

代入 ${l_2}(X)$，

$$
\begin{align}
\sigma_b(X) & = x_6 \cdot l_1(X)+x_2 \cdot l_2(X) +x_4 \cdot l_3(X)\\ &
= x_6 \cdot \frac{(X-2)(X-3)}{2} - x_2 \cdot (X-1)(X-3) +x_4 \cdot \frac{(X-1)(X-2)}{2}
\end{align}
$$

对于 $w_c$

$$
\sigma_c(X)=out \cdot l_1(X)+x_5 \cdot l_2(X) +x_6 \cdot l_3(X)
$$

$$
\begin{align}
\sigma_c(X) & = out \cdot l_1(X)+x_5 \cdot l_2(X) +x_6 \cdot l_3(X)\\ &
= out \cdot \frac{(X-2)(X-3)}{2} - x_5 \cdot (X-1)(X-3) +x_6 \cdot \frac{(X-1)(X-2)}{2}
\end{align}
$$

构造插值多项式结束以后，如果你想检查所得的 $\sigma_c(X)$ 是否对应表内的值，我们可以代入 X 的值进行验证，比如：

- 当 X=1 的时候，看 $\sigma_c(1)$ 是否 = out ，计算过程如下：

$$
\begin{align}
\sigma_c(1) & = out \cdot \frac{(1-2)(1-3)}{2} - x_5 \cdot (1-1)(1-3) +x_6 \cdot \frac{(1-1)(1-2)}{2} \\&
= out
\end{align}
$$

- 当 X=2 的时候，看 $\sigma_c(2)$ 是否 = $x_5$ ，计算过程如下：

$$
\begin{align}
\sigma_c(2) & = out \cdot \frac{(2-2)(2-3)}{2} - x_5 \cdot (2-1)(2-3) +x_6 \cdot \frac{(2-1)(2-2)}{2} \\&
= x_5
\end{align}
$$

- 当 X=3 的时候，看 $\sigma_c(3)$ 是否 = $x_6$ ，计算过程如下：

$$
\begin{align}
\sigma_c(3) & = out \cdot \frac{(3-2)(3-3)}{2} - x_5 \cdot (3-1)(3-3) +x_6 \cdot \frac{(3-1)(3-2)}{2} \\&
= x_6
\end{align}
$$

同样可以验证 $\sigma_a(X)$ 和 $\sigma_b(X)$。

如果验证通过，那么非常好，说明我们的式子计算没有问题，前置工作准备结束。接下来，**我们可以带入未知点进行插值检测，**比如我取一个随机值，让 X=1.5（其实无论是 i 和 X 都是在同一个[0,100]的范围里，然而 i 是索引，是已知的条件，借助 i 我们可以构造拉格朗日插值多项式，从而让也在同一个范围内的随机值 X 得以代入验证）。

换句话来说，在原来的 表1 中，我们是没有 i=1.5 这一行的，这是因为我们在计算的时候所看到的视图内容不同，实际上是存在 i=1.5 这一行，只是我们看不见，需要 Verifier 和 Prover 交互，这也是我们构建拉格朗日插值多项式的意义。我们通过已有的 i=1,2,3 构造了拉格朗日插值多项式，之后我们计算范围内任意 X 处多项式的值，最后再把这个计算出的值进行对照。如果随机的这一次挑战检查 X 处计算的值没有问题，那么说明这个范围内的值都没有问题，Prover 没有作弊。

增加 i=1.5 的情况，如表3

![表3](/ZKP-PLONK/images/PLONK多项式编程/表3.png)

我们可以计算一下：

$$
\begin{align}
\sigma_c(1.5) & = out \cdot \frac{(1.5-2)(1.5-3)}{2} - x_5 \cdot (1.5-1)(1.5-3) +x_6 \cdot \frac{(1.5-1)(1.5-2)}{2} \\&
=  0.375 out+0.75x_5-0.125x_6
\end{align}

$$

- latex
    
    \begin{array}{c|c|c|c|}
    \texttt{i} & {w_a} & {w_b} & {w_c}  \\
    \hline
    \texttt{1} & x_5 & x_6 & out \\
    \texttt{2} & x_1 & x_2 & x_5 \\
    \texttt{3} & x_3 & x_4 & x_6 \\
    \\
    \texttt{...} & ... & ... & ... \\
    \\
    \texttt{100} & ... & ... & ... \\
    \end{array}
    

![表2](https://prod-files-secure.s3.us-west-2.amazonaws.com/eefc8c39-e4fd-44c9-b56e-b7fb5a02f2be/a7356a41-a092-45ab-80fb-e847291f6a66/QianJianTec1720176061860.png)

表2

上图（表2）是在表1 的基础之上做了扩展，从表1 的 3*3，变成 3*100。

假如一个电路总共有 N 个约束，那么 Prover 可以通过多项式编码的方式把多个约束压缩成一个约束，让 Verifier 轻松检查。

让 v 花最小代价去检查证明（第一章里的表，不需要一行行检查）
纵向编码
100行，用一个/若干的多项式去编码三列，把原来 3*100的表，变成3个多项式（提炼 general 的多项式），V 就省力
变成多项式：其有性质，v 只要检查其中一个点，不需要每个点都满足，三个多项式检查同一个点