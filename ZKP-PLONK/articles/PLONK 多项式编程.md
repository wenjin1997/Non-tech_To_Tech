# 前言

在上篇文章里，我们提到，如果要实现协议验证的过程，Prover 在开始的时候通过多项式编码的方式对 $W$ 表格的每一列进行编码，然后将编码后的结果发给 Verifier 去验证；通过进一步的交互，可以验证等式

$$
q_{L}(X) \cdot w_{a}(X) + q_{R}(X) \cdot w_{b}(X) + q_{M}(X)\cdot(w_{a}(X)\cdot w_{b}(X)) + q_{C}(X) -  q_{O}(X)\cdot w_{c}(X) \overset{?}{=} 0
$$

是否成立。

这是仅在 Prover 是诚实的情况下，我们去验证一个电路的正确性。但是 Prover 很有可能会作恶，为了预防 Prover 作恶，保证电路的正确性和安全性，并在满足约束的情况下，我们需要再验证 $(\sigma_a(X),\sigma_b(X),\sigma_c(X))$ 与 $(w_a(X),w_b(X),w_c(X))$ 之间的关系。

其中：

$(\sigma_a(X),\sigma_b(X),\sigma_c(X))$ 是 Prover 计算的多项式，它们通常表示电路中的输入和中间结果；

$(w_a(X),w_b(X),w_c(X))$ 是预先定义的权重多项式，它们表示电路的结构。

简单来说，其实整个验证的过程最终就是把电路的正确性检查转换成一组加法/乘法的多项式约束。

</br>

为什么要这样的做呢？当然是**提高效率，降低成本**。

首先，

我们以第一章里的矩阵 $W$ 的表格形式「表1-1」为例，它遵循纵向编码的原则，也就是说每一列都可以用一个多项式去表示这一列下的内容计算规则。

目前只有三列，所以即便是逐行检查也不需要花太多时间，但是一旦行数增多到 100 行，那么一行行检查就特别耗费精力，Verifier 需要很强的算力。

因此，可以用一个/若干的多项式去编码三列，把 3*100 的表，变成 3 个多项式来表示。（这点可以结合 excel 表格计算公式来理解，很类似）

<img src="/ZKP-PLONK/images/PLONK多项式编程/表1-1.png" width="40%" />
「表1-1」


其次，变成多项式还有一个天生自带的 buff，假设矩阵 $W$ 的表格可以成功地只用多项式来表示，当 Verifier 进行验证的时候，Verifier 并不需要验证所有域上的点，就可以成功验证电路的正确性。

</br>

**具体来说：**

1. 假设电路的约束可以表示成为一个 3*100 的表，每一行代表一个约束条件。
2. 通过多项式编码的方式，将这 3×100 的表压缩成三个多项式 $σa(X),σb(X),σc(X)$。这些多项式可以通过某种方式（例如拉格朗日插值）从原始约束中构造出来。
3. Verifier 只需要检查这三个多项式在某一个随机点 $X=z$ 上是否满足约束条件。具体来说，Verifier 会检查：

$$
\sigma_a(z)⋅\sigma_b(z)=\sigma_c(z)
$$

如果这个等式在随机点 $z$ 上成立，那么可以高度概率地认为 3×100 这个表里的内容在整个域上都是成立的。

我们结合实例再看一遍，看看具体是怎么进行计算的：

<img src="/ZKP-PLONK/images/PLONK多项式编程/表1-1.png" width="40%" />
「表1-1」

</br>

还是以「表1-1」 为例，假设目前表格只有 3*3 ，那么表格中给出的插值点 i 及其对应的值如下：

- 插值点：i = 1,2,3
- 对应的值：
    - $w_a$: $x_5,x_1,x_3$
    - $w_b$: $x_6,x_2,x_4$
    - $w_c$: $out,x_5,x_6$

</br>

接下来我们**开始构造拉格朗日基函数**：

对于每个 i，拉格朗日基函数 ${l_i}{(X)}$ 的定义是：

$$
{l_i}{(X)}=\prod_{j\neq i}^{} \frac{X-j}{i-j} 
$$

具体到插值点：i = 1,2,3，我们分别求出 ${l_1}{(X)},{l_2}{(X)},{l_3}{(X)}$，

- 对于 i = 1，

$$
{l_1}{(X)}=\frac{(X-2)(X-3)}{(1-2)(1-3)} =\frac{(X-2)(X-3)}{2} 
$$

- 对于 i = 2，

$$
{l_2}{(X)}=\frac{(X-1)(X-3)}{(2-1)(2-3)} = -(X-1)(X-3)
$$

- 对于 i = 3，

$$
{l_3}{(X)}=\frac{(X-1)(X-2)}{(3-1)(3-2)} =\frac{(X-1)(X-2)}{2} 
$$

接下来，结合「表1-1」 中的内容，和上面已经求出的对应 i 的拉格朗日基函数，**我们开始构造插值多项式**：

对于 $w_a$

$$
\sigma_a(X)=x_5 \cdot l_1(X)+x_1 \cdot l_2(X) +x_3 \cdot l_3(X)
$$

把 ${l_1}(X)$ 代入，

$$
\begin{align}
\sigma_a(X) & = x_5 \cdot l_1(X)+x_1 \cdot l_2(X) +x_3 \cdot l_3(X) & \\ & = x_5 \cdot \frac{(X-2)(X-3)}{2} - x_1 \cdot(X-1)(X-3)+x_3 \cdot\frac{(X-1)(X-2)}{2}
\end{align}
$$

对于 $w_b$

$$
\sigma_b(X)=x_6 \cdot l_1(X)+x_2 \cdot l_2(X) +x_4 \cdot l_3(X)
$$

把 ${l_2}(X)$ 代入，

$$
\begin{align}
\sigma_b(X) & = x_6 \cdot l_1(X)+x_2 \cdot l_2(X) +x_4 \cdot l_3(X)\\ & = x_6 \cdot \frac{(X-2)(X-3)}{2} - x_2 \cdot (X-1)(X-3) +x_4 \cdot \frac{(X-1)(X-2)}{2}
\end{align}
$$

对于 $w_c$

$$
\sigma_c(X)=out \cdot l_1(X)+x_5 \cdot l_2(X) +x_6 \cdot l_3(X)
$$

把 ${l_3}(X)$ 代入，

$$
\begin{align}
\sigma_c(X) & = out \cdot l_1(X)+x_5 \cdot l_2(X) +x_6 \cdot l_3(X)\\ & = out \cdot \frac{(X-2)(X-3)}{2} - x_5 \cdot (X-1)(X-3) +x_6 \cdot \frac{(X-1)(X-2)}{2}
\end{align}
$$

构造插值多项式结束以后，如果你想检查所得的 $\sigma_c(X)$ 是否对应表内的值，我们可以代入 X 的值进行验证，比如：

- 当 X=1 的时候，看 $\sigma_c(1)$ 是否 = out ，计算过程如下：

$$
\begin{align}
\sigma_c(1) & = out \cdot \frac{(1-2)(1-3)}{2} - x_5 \cdot (1-1)(1-3) +x_6 \cdot \frac{(1-1)(1-2)}{2} \\ & = out
\end{align}
$$

- 当 X=2 的时候，看 $\sigma_c(2)$ 是否 = $x_5$ ，计算过程如下：

$$
\begin{align}
\sigma_c(2) & = out \cdot \frac{(2-2)(2-3)}{2} - x_5 \cdot (2-1)(2-3) +x_6 \cdot \frac{(2-1)(2-2)}{2} \\ & = x_5
\end{align}
$$

- 当 X=3 的时候，看 $\sigma_c(3)$ 是否 = $x_6$ ，计算过程如下：

$$
\begin{align}
\sigma_c(3) & = out \cdot \frac{(3-2)(3-3)}{2} - x_5 \cdot (3-1)(3-3) +x_6 \cdot \frac{(3-1)(3-2)}{2} \\ & = x_6
\end{align}
$$

同样可以验证 $\sigma_a(X)$ 和 $\sigma_b(X)$。

如果验证通过，那么非常好，说明我们的式子计算没有问题，前置工作准备结束。

**总结一下**，上面那么多内容其实就是做了这样一项工作：根据拉格朗日插值法，通过「表1-1」里已知的关系构造出「表2」

<img src="/ZKP-PLONK/images/PLONK多项式编程/表1-1.png" width="40%" />
「表1-1」

<img src="/ZKP-PLONK/images/PLONK多项式编程/表1-2.png" width="40%" />
「表1-2」

<img src="/ZKP-PLONK/images/PLONK多项式编程/表2.png" width="70%" />
「表2」

可能会有点绕，因为涉及一些转化。其中，在「表1-1」中，定义域是 $i\in {1,2,3}$，看「表1-2」会更加清晰；而在 $\sigma_a(X)$ 的插值多项式中，定义域就会变得更大，插值多项式的构建其实也间接完成了扩域（后面会详细讲述），所以我们可以代入不仅限于 「表2」中的 X={1,2,3} 的示例。

我们通过已有的三个插值点构造了「表2」 的拉格朗日插值多项式，有了它以后，我们可以带入未知点进行插值点的数值运算，验证是否满足 $\sigma_a(X)\cdot \sigma_b(X)=\sigma_c(X)$。如果随机挑选的 X 可以满足 $\sigma_a(X)\cdot \sigma_b(X)=\sigma_c(X)$，那么说明这个范围内的值都都适用，Prover 没有作恶。


</br>

# 多项式的概率检查
如果你看懂了前言部分，那么接下来的内容就不难理解了。

在许多密码学协议和复杂计算的验证过程中，电路（可以是布尔电路或代数电路）常用于描述和实现计算逻辑。验证这些计算的正确性是一个重要问题，而直接验证每一步计算通常是不切实际的。Schwartz-Zippel 定理提供了一种高效的概率验证方法。

什么是 Schwartz-Zippel 定理呢？

通过引入随机挑战值，我们可以将原本需要逐一验证的多个条件合并为一个简化的验证步骤。这种方法利用了「多项式随机挑战」的理论，即通过验证多项式在一个随机点上的值，可以高概率确定两个多项式在整个定义域上的相等性。

具体来说，如果有两个多项式 $f(X)$ 和 $g(X)$，它们的次数均不超过 $d$，那么 Verifier 只需要给出一个随机挑战值 $\zeta \in \mathbb{F}$，计算 $f(\zeta)$ 是否等于 $g(\zeta)$ 即可大概率得知 $f(X) = g(X)$，其中出错的概率 $\leq \frac{d}{|\mathbb{F}|}$。只要保证 $\mathbb{F}$ 足够大，那么检查出错的概率就可以忽略不计。

这个原理就被称为 Schwartz-Zippel 定理。

假如要验证两个向量 $\vec{a} + \vec{b}$ 是否等于 $\vec{c}$，为了可以一步挑战验证，我们要先把三个向量编码成多项式。

一种最直接的方案是把向量当作多项式的「系数」进行编码

$$
\begin{split}
a(X) &= a_0 + a_1X+a_2X^2 + \cdots + a_{n-1}X^{n-1}\\
b(X) &= b_0 + b_1X+b_2X^2 + \cdots + b_{n-1}X^{n-1}\\
c(X) &= c_0 + c_1X+c_2X^2 + \cdots + c_{n-1}X^{n-1}
\end{split}
$$

显然，如果 $a_i+ b_i = c_i$，那么 $a(X)+b(X)=c(X)$。然后我们可以通过挑战一个随机数 $\zeta$ 来检验三个多项式在 $X=\zeta$ 处的取值，验证：

$$
a(\zeta)+b(\zeta)\overset{?}{=}c(\zeta)
$$

如果上式成立，那么 $\vec{a} + \vec{b}=\vec{c}$ 。


</br>

# Lagrange 插值 与 Evaluation Form
但是，假如我们要验证 $\vec{a}\circ\vec{b}\overset{?}{=}\vec{c}$，用系数编码的方式就不容易处理了。当 $a(X)\cdot b(X)$ 会产生很多的交叉项，这些交叉项的系数来自于 $a(X)$ 和 $b(X)$ 的各个不同次幂的项。

我们可以具体来算一下，假设：

$a(X)=a_0 + a_1X+a_2X^2$

$b(X)=b_0 + b_1X+b_2X^2$

$c(X)=c_0 +c_1X+c_2X^2+c_3X^3+C_4X^4$

那么

$$
\begin{align}
a(X)\cdot b(X) & = (a_0 + a_1X+a_2X^2)\cdot(b_0 + b_1X+b_2X^2) & \\ & = a_0b_0+(a_0b1+b_0a1)X+(a_0b_2+a_1b_1+a_2b_0)X^2+\cdots
\end{align}
$$

并且 $a_i\cdot b_i$ 和 $c_i$ 的项并不对应到 $X^i$ 的系数，比如 $a_1\cdot b_1$ 的系数出现在 $X^2$ 上，但同时 $X^2$ 项的系数组成还有 $a_0b_2$ 和 $a_2b_0$。而 $c_1$ 是 $X^1$ 的系数。

