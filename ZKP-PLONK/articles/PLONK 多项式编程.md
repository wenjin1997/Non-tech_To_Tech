# 前言

在上篇文章里，我们提到，如果要实现协议验证的过程，Prover 在开始的时候通过多项式编码的方式对 $W$ 表格的每一列进行编码，然后将编码后的结果发给 Verifier 去验证；通过进一步的交互，可以验证等式

$$
q_{L}(X) \cdot w_{a}(X) + q_{R}(X) \cdot w_{b}(X) + q_{M}(X)\cdot(w_{a}(X)\cdot w_{b}(X)) + q_{C}(X) -  q_{O}(X)\cdot w_{c}(X) \overset{?}{=} 0
$$

是否成立。

这是仅在 Prover 是诚实的情况下，我们去验证一个电路的正确性。但是 Prover 很有可能会作恶，为了预防 Prover 作恶，保证电路的正确性和安全性，并在满足约束的情况下，我们需要再验证 $(\sigma_a(X),\sigma_b(X),\sigma_c(X))$ 与 $(w_a(X),w_b(X),w_c(X))$ 之间的关系。

$(\sigma_a(X),\sigma_b(X),\sigma_c(X))$ 是 Prover 计算的多项式，它们通常表示电路中的输入和中间结果；

$(w_a(X),w_b(X),w_c(X))$ 是预先定义的权重多项式，它们表示电路的结构。

简单来说，其实整个验证的过程最终就是把电路的正确性检查转换成一组加法/乘法的多项式约束。

为什么要这样的做呢？当然是提高效率，降低成本。

首先，

我们以第一章里的矩阵 $W$ 的表格形式「表1-1」为例，它遵循纵向编码的原则，也就是说每一列都可以用一个多项式去表示这一列下的内容计算规则。

目前只有三列，所以即便是逐行检查也不需要花太多时间，但是一旦行数增多到 100 行，那么一行行检查就特别耗费精力，Verifier 需要很强的算力。

因此，可以用一个/若干的多项式去编码三列，把 3*100 的表，变成 3 个多项式来表示。（这点可以结合 excel 表格计算公式来理解，很类似）

<img src="/ZKP-PLONK/images/PLONK多项式编程/表1-1.png" width="40%" />
「表1-1」


其次，变成多项式还有一个天生自带的 buff，假设矩阵 $W$ 的表格可以成功地只用多项式来表示，当 Verifier 进行验证的时候，Verifier 并不需要验证所有域上的点，就可以成功验证电路的正确性。

具体来说：

1. 假设电路的约束可以表示成为一个 3*100 的表，每一行代表一个约束条件。
2. 通过多项式编码的方式，将这 3×100 的表压缩成三个多项式 $σa(X),σb(X),σc(X)$。这些多项式可以通过某种方式（例如拉格朗日插值）从原始约束中构造出来。
3. Verifier 只需要检查这三个多项式在某一个随机点 $X=z$ 上是否满足约束条件。具体来说，Verifier 会检查：

$$
\sigma_a(z)⋅\sigma_b(z)=\sigma_c(z)
$$

如果这个等式在随机点 $z$ 上成立，那么可以高度概率地认为 3×100 这个表里的内容在整个域上都是成立的。

我们结合实例再看一遍，看看具体是怎么进行计算的：

<img src="/ZKP-PLONK/images/PLONK多项式编程/表1-1.png" width="40%" />
「表1-1」

还是以「表1-1」 为例，假设目前表格只有 3*3 ，那么表格中给出的插值点 i 及其对应的值如下：

- 插值点：$i = 1,2,3$
- 对应的值：
    - $w_a$: $x5,x1,x3$
    - $w_b$: $x6,x2,x4$
    - $w_c$: $out,x5,x6$

接下来我们**开始构造拉格朗日基函数**：

对于每个 i，拉格朗日基函数 ${l_i}{(X)}$ 的定义是：

$$
{l_i}{(X)}=\prod_{j\neq i}^{} \frac{X-j}{i-j} 
$$

具体到插值点：i = 1,2,3，我们分别求出 ${l_1}{(X)},{l_2}{(X)},{l_3}{(X)}$，

- 对于 i = 1，

$$
{l_1}{(X)}=\frac{(X-2)(X-3)}{(1-2)(1-3)} =\frac{(X-2)(X-3)}{2} 
$$

- 对于 i = 2，

$$
{l_2}{(X)}=\frac{(X-1)(X-3)}{(2-1)(2-3)} = -(X-1)(X-3)
$$

- 对于 i = 3，

$$
{l_3}{(X)}=\frac{(X-1)(X-2)}{(3-1)(3-2)} =\frac{(X-1)(X-2)}{2} 
$$

接下来，结合「表1-1」 中的内容，和上面已经求出的对应 i 的拉格朗日基函数，**我们开始构造插值多项式**：

对于 $w_a$

$$
\sigma_a(X)=x_5 \cdot l_1(X)+x_1 \cdot l_2(X) +x_3 \cdot l_3(X)
$$

把 ${l_1}(X)$ 代入，

$$
\begin{align}
\sigma_a(X) & = x_5 \cdot l_1(X)+x_1 \cdot l_2(X) +x_3 \cdot l_3(X) & \\ & = x_5 \cdot \frac{(X-2)(X-3)}{2} - x_1 \cdot(X-1)(X-3)+x_3 \cdot\frac{(X-1)(X-2)}{2}
\end{align}
$$

对于 $w_b$

$$
\sigma_b(X)=x_6 \cdot l_1(X)+x_2 \cdot l_2(X) +x_4 \cdot l_3(X)
$$

把 ${l_2}(X)$ 代入，

$$
\begin{align}
\sigma_b(X) & = x_6 \cdot l_1(X)+x_2 \cdot l_2(X) +x_4 \cdot l_3(X)\\ & = x_6 \cdot \frac{(X-2)(X-3)}{2} - x_2 \cdot (X-1)(X-3) +x_4 \cdot \frac{(X-1)(X-2)}{2}
\end{align}
$$

对于 $w_c$

$$
\sigma_c(X)=out \cdot l_1(X)+x_5 \cdot l_2(X) +x_6 \cdot l_3(X)
$$

把 ${l_3}(X)$ 代入，

$$
\begin{align}
\sigma_c(X) & = out \cdot l_1(X)+x_5 \cdot l_2(X) +x_6 \cdot l_3(X)\\ & = out \cdot \frac{(X-2)(X-3)}{2} - x_5 \cdot (X-1)(X-3) +x_6 \cdot \frac{(X-1)(X-2)}{2}
\end{align}
$$

构造插值多项式结束以后，如果你想检查所得的 $\sigma_c(X)$ 是否对应表内的值，我们可以代入 X 的值进行验证，比如：

- 当 X=1 的时候，看 $\sigma_c(1)$ 是否 = out ，计算过程如下：

$$
\begin{align}
\sigma_c(1) & = out \cdot \frac{(1-2)(1-3)}{2} - x_5 \cdot (1-1)(1-3) +x_6 \cdot \frac{(1-1)(1-2)}{2} \\ & = out
\end{align}
$$

- 当 X=2 的时候，看 $\sigma_c(2)$ 是否 = $x_5$ ，计算过程如下：

$$
\begin{align}
\sigma_c(2) & = out \cdot \frac{(2-2)(2-3)}{2} - x_5 \cdot (2-1)(2-3) +x_6 \cdot \frac{(2-1)(2-2)}{2} \\ & = x_5
\end{align}
$$

- 当 X=3 的时候，看 $\sigma_c(3)$ 是否 = $x_6$ ，计算过程如下：

$$
\begin{align}
\sigma_c(3) & = out \cdot \frac{(3-2)(3-3)}{2} - x_5 \cdot (3-1)(3-3) +x_6 \cdot \frac{(3-1)(3-2)}{2} \\ & = x_6
\end{align}
$$

同样可以验证 $\sigma_a(X)$ 和 $\sigma_b(X)$。

如果验证通过，那么非常好，说明我们的式子计算没有问题，前置工作准备结束。

**总结一下**，上面那么多内容其实就是做了这样一项工作：根据拉格朗日插值法，通过「表1-1」里已知的关系构造出「表2」

<img src="/ZKP-PLONK/images/PLONK多项式编程/表1-1.png" width="40%" />
「表1-1」

<img src="/ZKP-PLONK/images/PLONK多项式编程/表1-2.png" width="40%" />
「表1-2」

<img src="/ZKP-PLONK/images/PLONK多项式编程/表2.png" width="70%" />
「表2」

可能会有点绕，因为涉及一些转化。其中，在「表1-1」中，定义域是 $i\in {1,2,3}$，看「表1-2」会更加清晰；而在 $\sigma_a(X)$ 的插值多项式中，定义域就会变得更大，插值多项式的构建其实也间接完成了扩域（后面会详细讲述），所以我们可以代入不仅限于 「表2」中的 X={1,2,3} 的示例。

我们通过已有的三个插值点构造了「表2」 的拉格朗日插值多项式，有了它以后，**我们可以带入未知点进行插值点的数值运算**，如果随机的这一次挑战检查 X 处计算的值没有问题，那么说明这个范围内的值都没有问题，Prover 没有作弊。


# 多项式的概率检查


# Lagrange 插值 与 Evaluation Form


