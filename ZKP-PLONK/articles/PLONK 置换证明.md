# 理解 PLONK（三）：置换证明

Plonkish 电路编码用两个矩阵 $(Q,\sigma)$ 描述电路的空白结构，其中 $Q$ 为运算开关， $\sigma$ 为置换关系，用来约束 $W$ 矩阵中的某些位置必须被填入相等的值。本文重点讲解置换证明（Permutation Argument）的原理。


## 回顾拷贝关系

$\sigma$ 为置换关系，但具体是什么样呢？ $\sigma$ 表示的是置换之前的位置到置换之后的位置。

举个例子，假设我们有两个多项式的待评估向量 $\vec{a}$ 和 $\vec{a}'$ ， $\vec{a’}$ 的元素通过置换从 $\vec{a’}$ 的对应位置获取。

那么假设有 $\vec{a}=[a_1,a_2,a_3]$ 和 $\vec{a}'=[a_3,a_1,a_2]$，以及一个置换 $\sigma = (1 \to 2,2 \to 3, 3 \to 1)$，其中置换 $\sigma$ 表示一种元素重排：

$\sigma(1) =2$ ，表示 $\vec{a(1)} = \vec{a'(2)}$
$\sigma(2) =3$ ，表示 $\vec{a(2)} = \vec{a'(3)}$
$\sigma(3) =1$ ，表示 $\vec{a(3)} = \vec{a'(1)}$


我们可以再接着回顾一下 Plonkish 的 $W$ 表格，总共有三列，行数按照 $2^2$ 对齐。

💡注：在 Plonkish 协议中，「行数按照 $2^2$ 对齐」的意思是，表格的总行数是 $2^2=4$ 的倍数。也就是说，表格中的行数会被填充或设计成 4 的倍数，以便于后续的计算和证明过程中的操作。这种对齐方式常用于简化计算和确保结构的一致性。具体见下图：


$$
\begin{array}{c|c|c|c|}
i & w_{a,i} & w_{b,i} & w_{c,i}  \\
\hline
1 & {\color{red}x_6} & {\color{blue}x_5} & {\color{green}out} \\
2 & x_1 & x_2 & {\color{red}x_6} \\
3 & x_3 & x_4 & {\color{blue}x_5} \\
4 & 0 & 0 & {\color{green}out} \\
\end{array}
$$

我们想约束 Prover 在填写 $W$ 表时，满足下面的拷贝关系： $w_{a,1}=w_{c,2}$   $w_{b,1}=w_{c,3}$ 与 $w_{c,1}=w_{c,4}$，换句话说， $w_{a,1}$ 位置上的值需要被拷贝到 $w_{c,2}$ 处，而 $w_{b,1}$ 位置上的值需要被拷贝到 $w_{c,3}$ 处， $w_{c,1}$ 位置上的值被拷贝到 $w_{c,4}$ 处。

问题的挑战性在于，**Verifier 要在看不到 $W$  表格的情况下，仅通过一次随机挑战就能完成 $W$ 表格中多个拷贝关系的证明**。

要知道，Plonk 的「拷贝约束」是通过「置换证明」（Permutation Argument）来实现，即把表格中需要约束相等的那些值进行循环换位，然后证明换位后的表格和原来的表格完全相等。

这就是我们为什么要引入一个 $\sigma$ 来表示置换关系。

有了 $\sigma$， 这个问题就可以被简化为证明：

1. 两个等长向量 $\vec{a}$ 和 $\vec{a}'$ 满足一个已知的置换 $\sigma$；
2. $\vec{a}=\vec{a}'$


$$
a_i=a'_{\sigma(i)}
$$

再举一个例子，假设 $\vec{a}=(a_0,a_1,a_2,a_3)$， $\vec{a}'=(a_1,a_2,a_3,a_0)$，即他们满足一个「左移循环换位」的置换关系，那么 $\sigma=\\{0\to 1; 1\to 2; 2\to 3; 3\to0\\}$。如果能证明 $\vec{a}=\vec{a}'$ ，那么两个向量对应位置的值都应该相等，

$$
\begin{array}{c{|}c|c|c|c|c}
\vec{a} & a_0 & a_1 & a_2 & a_3 \\
\hline
\vec{a}' & a_1 & a_2 & a_3 & a_0 \\
\end{array}
$$

那么 $a_0=a_1$， $a_1=a_2$， $a_2=a_3$， $a_3=a_0$，于是可以得出结论： $a_0=a_1=a_2=a_3$，即 $\vec{a}$ 中的全部元素都相等。

对于表格 $W$ ，我们只需要针对那些需要相等的位置进行循环换位，然后让 Prover 证明 $W$ 表格和经过循环换位后的 $W'$ 表格相等，那么可实现拷贝约束。证明两个表格相等，这个可以通过多项式编码，然后进行概率检验的方式完成。剩下的工作就是如何让 Prover 证明 $W'$  确实是（诚实地）按照事先约定的方式进行循环移位。

那么接下来就是理解如何让 Prover 证明两个向量之间满足某一个「置换关系」。 置换证明（Permutation Argument）是 Plonk 协议中的核心部分，为了解释它的工作原理，我们先从一个基础协议开始——连乘证明（Grand Product Argument）。


## 冷启动：Grand Product 

假设我们要证明下面的「连乘关系」 ：

$$
p = q_0\cdot q_1 \cdot q_2 \cdot \cdots \cdot q_{n-2}
$$

这里处理连乘的基本思路是：首先让 Prover 利用一组单乘的证明来实现多个数的连乘证明，然后再通过多项式的编码，交给 Verifier 进行概率检查。

强调下：思路中的关键点是**如何把一个连乘计算转换成多次的单乘计算**。

其实说得通俗易懂点逐步搭建积木塔：

连乘计算：就像一次性把所有积木叠在一起，形成一座高塔。
多次单乘计算：就像每次只添加一块积木，逐步将塔搭建到相同的高度。

假设我们要计算 $a \cdot b \cdot c \cdot d$

第一步：计算 $a\cdot b=e$
第二步：用结果 $e$ 继续乘以 $c$ ，得到 $e×c=f$
第三步：再用结果 $f$ 乘以 $d$ ，得到最终结果 $f \cdot d$

这样，通过三次单独的乘法操作，我们完成了整体的连乘运算。每一步都像是在原有的积木塔上加一块新的积木。

为了把一个连乘计算转换成多次的单乘计算，我们需要通过引入一个「辅助向量」，把「连乘」的计算看成是一步步的单乘计算，然后辅助向量表示每次单乘之后的「中间值」。

$$
\begin{array}{c|c|l}
q_i & r_i & \ \ q_i\cdot r_i \\
\hline
q_0 & r_0=1  & r_1=q_0\\
q_1 & r_1 & r_2=q_0\cdot q_1\\
q_2 & r_2 & r_3=q_0\cdot q_1\cdot q_2\\
\vdots & \vdots & \vdots\\
q_{n-2} & r_{n-2} & r_{n-1} = p\\
\end{array}
$$

上面表格表述了连乘过程的计算轨迹（Trace），每一行代表一次单乘，顺序从上往下计算，最后一行计算出最终的结果。

表格的最左列为要进行连乘的向量 $\\{q_i\\}$，中间列 $\\{r_i\\}$ 为引入的辅助变量，记录每次「单乘之前」的中间值，最右列表示每次「单乘之后」的中间值。

不难发现，「中间列」向量 $\vec{r}$ 向上挪一行与「最右列」几乎一致，除了最后一个元素。该向量的第一个元素用了常数 $1$ 作为计算初始值，「最右列」最后一个向量元素为计算结果。

<img src="/ZKP-PLONK/images/PLONK算数化「1」/图1:对应关系" width="40%" />
「图1:对应关系」


向量 $\vec{r}$ 是一个 Accumulator，即记录连乘计算过程中的每一个中间结果：

$$
r_k = \prod_{i=0}^{k-1}q_i
$$

那么显然我们可以得到下面的递归式：

$$
r_0 = 1, \qquad r_{k+1}=q_{k}\cdot r_{k}
$$

于是，表格的三列编码后的多项式也将满足下面三个约束。

$$
L_0(X)\cdot(r(X)-1)=0, \qquad \forall X\in H 
$$

上面这里用到了拉格朗日插值来构建这个约束，让 $r(\qquad X)$ 的初始值为 $1$。

第二个约束为递归的乘法关系：

$$
q(X)\cdot r(X) = r(\omega\cdot X), \qquad \forall X\in H\backslash\\{\omega^{-1}\\}
$$

💡注：
1. 第二个约束的目的是要验证这两个等式的结果，分别计算 $q(\qquad X)$ \cdot $r(\qquad X)$ 和 $\omega \cdot \qquad X$， 然后比较它们的结果来确认关系是否成立。
2. 其中 $\omega \cdot \qquad X$ 代表的是对 $\qquad X$ 进行缩放或移位。$\omega$ 是一个固定值，是指单位根，用于在循环群中的移位；$\qquad X$ 是当前的点。通过乘以 $\omega$，我们将 $\qquad X$ 移动到一个新的点。
3. 为什么需要将 $\qquad X$ 乘以 $\omega$ ？主要原因就是它能保证每次移位（或缩放）是等比的，并且在循环群结构中这些点之间的间隔是均匀的。例如，$\omega=e^{\frac{2πi}{n}}$ 是 $n$ 次单位根，它在复数平面上对应一个固定的旋转角度。每次将 $\qquad X$ 乘以 $\omega$，相当于在复数平面上旋转固定的角度。这样可以确保点在一个完整的循环中是均匀分布的。
4. 为什么要排除 $\qquad X=\omega_{-1}$ 的情况？是因为在这种情况下，可能会导致一些问题：
- 当 $\qquad X=\omega_{-1}$ 时，某些多项式或函数可能在这个点上有零点，导致分母为零或计算不稳定；
- 如果在这个点上某些关系不满足或不具有唯一性，可能会影响整个证明的正确性和一致性；
- 特定值可能会破坏我们依赖于对称性或特定循环性质的证明结果。


第三个约束最后结果 $r_{n-1}=p$：

$$
L_{n-1}(X)\cdot(r(X)-p)=0, \qquad \forall X\in H
$$

这个约束的目的是确保 $r(\qquad X)$ 在终点的结果为 $p$。


**我们可以用一个小技巧来简化上面的三个约束**。我们把计算连乘的表格添加一行，令 $q_{n-1}=1/p$（注意： $p$ 为 $\vec{q}$ 向量的连乘积）

$$
\begin{array}{c|c|c}
q_i & r_i & q_i\cdot r_i \\
\hline
q_0 & 1  & r_0\\
q_1 & r_0 & r_1\\
q_2 & r_1 & r_2\\
\vdots & \vdots & \vdots\\
q_{n-2} & r_{n-2} & r_{n-1}\\
q_{n-1}=\frac{1}{p} & r_{n-1} & 1 \\
\end{array}
$$

这样一来， $r_n=r_0=1$ 。最右列恰好是 $\vec{r}$ 的循环移位。并且上面表格的每一行都满足「乘法关系」！于是，我们可以用下面的多项式约束来表示递归的连乘：

$$
q(X)\cdot r(X)=r(\omega\cdot X), \qquad \forall X\in H
$$

💡注：通过上述的小技巧，使得 $q(X)\cdot r(X) = r(\omega\cdot X), \qquad \forall X\in H\backslash\\{\omega^{-1}\\} \to q(X)\cdot r(X)=r(\omega\cdot X), \qquad \forall X\in H$ ，意味着原本需要排除的特定点 $ω^{-1}$ 现在也符合这个关系在整个 $\qquad H$ 上成立。


接下来，Verifier 可以挑战下面的多项式等式：

$$
L_0(X)\cdot(r(X)-1)+\alpha\cdot(q(X)\cdot r(X)-r(\omega\cdot X))=h(X)\cdot z_H(X)
$$


其中 $\alpha$ 是用来聚合多个多项式约束的随机挑战数。其中 $h(X)$ 为商多项式， $z_H(X)=(X-1)(X-\omega)\cdots(X-\omega^{n-1})$。

接下来，通过 Schwartz-Zippel 定理，Verifier 可以给出挑战数 $\zeta$ 来验证上述多项式等式是否成立。

再说说 Schwartz-Zippel 定理吧，结合这个例子具体来看：

首先，构造差多项式：

令 $A(X)=L_0(X)\cdot(r(X)-1)+\alpha\cdot(q(X)\cdot r(X)-r(\omega\cdot X))$  ，
$B(X)=h(X)\cdot z_H(X)$ ，

那么 $R(X)=A(X)-B(X)$ ，$d$ 是 $R(X)¥$ 的阶数；

之后就要用到 Schwartz-Zippel 定理验证：

因为是在集合 $H$ 中，挑选随机数 $\zeta $，

所以计算 $R(\zeta)$ 的值：

如果 $R(\zeta)=0$， 则 $A(X)=B(X)$，可能是小概率事件，需要再次验证；如果再次验证还是为 $R(\zeta)=0$ 的情况，还要再次验证，尽可能确保不是小概率事件；
如果 $R(\zeta) \ne 0$，则 $A(X) \ne B(X)$，则说明原等式不成立；

> PS:多项式 $R(X)=0$ 的概率最大是 $\left | {H} \right | $


💡注：前面章节中所提到的 $q_L \circ w_a +q_R \cric w_b +q_M \cric(w_a \cdot w_b)-q_C+q_O \cdot w_c = 0$ 是用来建立约束关系的，通常是约束多项式，用于表达具体的算术电路约束条件；而 $L_0(X)\cdot(r(X)-1)+\alpha\cdot(q(X)\cdot r(X)-r(\omega\cdot X))=h(X)\cdot z_H(X)$ 形式的多项式通常出现在构建多项式等式以验证某种代数性质时，比如多项式承诺方案中，用于证明整个电路或协议的完整性和正确性。

到此为止，如果我们已经理解了如何证明一个向量元素的连乘，那么接下来的问题是如何利用「连乘证明」来实现「Multiset 等价证明」（Multiset Equality Argument）。
