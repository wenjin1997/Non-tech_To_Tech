# 前言

算术化是指把计算转换成数学对象，然后进行零知识证明。 

Plonkish 算术化是 Plonk 证明系统特有的算术化方法，在 Plonkish 出现之前，主流的电路表达形式为 R1CS，被 Pinocchio，Groth16，Bulletproofs 等广泛采用。2019 年 Plonk 方案提出了一种看似复古的电路编码方式，但由于 Plonk 方案将多项式的编码应用到了极致，它不再局限于算术电路中的「加法门」和「乘法门」，而是可以支持更灵活的「自定义门」与「查表门」。

本文里，我们将直切主题，先了解 Plonkish 算术化方案，明白一个电路里的组成部分和其背后的运算逻辑，最后可以对比 Plonkish 和 R1CS 算数化的区别，感受二者的差别，更加深入理解 Plonkish 编码存在的意义。

# Plonkish算术门
首先，我们先了解电路的基本构成，看看静态下的空白电路有哪些组成部分，我们可以看下图的案例电路：

<img src="/ZKP-PLONK/images/「1」PLONK算术化/图：电路1.png" width="40%" />

上图「图1：电路1」由几部分构成：算术门、左右输入引脚、输出引脚和引线。

我们把其中三个算术门编号为 `#1`、`#2`、`#3`，其中：

`#1` 是乘法门，这个门的左输入引脚是 $x_5$，右输入引脚 $x_6$，输出引脚是 $out$；

`#2` 是加法门，这个门的左输入引脚是 $x_1$，右输入引脚是 $x_2$，输出引脚是 $x_5$；

`#3` 还是乘法门，这个门的左输入引脚是 $x_3$，右输入引脚是 $x_4$，输出引脚是 $x_6$

> 请注意：$x_5$ 和 $x_6$ 既做了 `#1` 的输入引脚，也分别做了 `#2` 和 `#3` 的输出引脚。

除了我们能看到的这些组成部分以外，隐形的是其中对应的数学关系，也就是这个电路要成立必须要满足的约束关系：

$$
\begin{array}{c}
x_1+ x_2 = x_5\\
x_3\cdot x_4=x_6\\
x_5\cdot x_6=out
\end{array}
$$

有了电路具体的约束关系后，我们可以将其中的关系转换成「矩阵」，这个矩阵可以用表格的形式来呈现，从而方便后续的计算。

**具体该怎么做呢？**

首先，我们可以定义一个矩阵 $W\in\mathbb{F}^{n\times 3}$ （不必管  $\mathbb{F}$ 到底是什么，只需要知道是在一定的范围内就可以； $n$ 为算数门的数量，对应为行；3 表示多项式变量名的数量，对应为列）来表示约束，约束关系等式就可以变成：

$$
\begin{array}{c|c|c|c|}
\texttt{i} & w_a & w_b & w_c  \\
\hline
\texttt{1} & x_5 & x_6 & out \\
\texttt{2} & x_1 & x_2 & x_5 \\
\texttt{3} & x_3 & x_4 & x_6 \\
\end{array}
$$

> 注：其中 $i$ 是表示电路中每个门的索引，从 1 开始逐行递增，它用来标识电路的每个门的位置。

在 Plonkish 中，如果 Prover 要向 Verifier 证明 Ta 知道某个秘密，那么需要用到一个固定的约束等式，验证电路的各个约束条件是否满足。只要这个固定的约束等式可以成立，就可以在不泄露秘密信息的情况下，验证电路的正确性。固定的约束等式等式如下：

$$
q_L \circ w_a + q_R \circ w_b + q_M\circ(w_a\cdot w_b) + q_C -  q_O\circ w_c \overset{?}{=} 0
$$

> 注：一般我们都会将所有的约束都移到等式的一侧。例如，在算术电路中，我们经常需要验证以下形式的方程：
> `左输入+右输入+乘法项+常数=输出`
> 为了表示这一点，我们可以将等式全部移到方程左边，并等于零：
> `左输入+右输入+乘法项+常数−输出=0`
> 这样有助于简化证明系统的构建和验证过程。例如在后续构建约束矩阵 $Q$ 的时候有选择器多项式的系数选择问题，办法其实很简单，只需要对应固定等式的算术关系即可，不需要进行符号的变换，可参考下图矩阵 $Q\in\mathbb{F}^{n\times5}$。



在上方固定的约束等式中：

- $q_L$， $q_R$， $q_M$， $q_C$， $q_O$ 是选择器多项式，用于选择特定的变量或操作
  - $q_L$ 表示左输入选择器
  - $q_R$ 表示右输入选择器
  - $q_M$ 表示乘法选择器
  - $q_C$ 表示常数选择器
  - $q_O$ 表示输出选择器
- $w_a$， $w_b$， $w_c$ 是电路中的变量（或是电线上的值）
  - $w_a$ 表示每个门的左输入引脚
  - $w_b$ 表示每个门的右输入引脚
  - $w_c$ 表示每个门的输入引脚
- $\circ$ 表示元素对应相乘，即哈达玛积（Hadamard Product）

- $\cdot$ 表示常规的乘法

为了验证电路，我们需要根据已有的约束关系来构建约束矩阵 $Q$ 

**具体要怎么构建呢？**

第一步，将约束都移到等式的一侧，所以：

第一个门 `#1`，原来是 $x_3\cdot x_4 = x_6$，转换成 $x_3\cdot x_4 - x_6=0$；

第二个门 `#2`， $x_1 + x_2 =x_5$，转换成 $x_1 + x_2 - x_5=0$；

第三个门 `#3`， $x_5 \cdot x_6 = out$，转换成 $x_5 \cdot x_6 - out=0$。

> 为什么要将所有值移到等式一边？
  1. 所有的约束等式形式统一为 $f(x) = 0$，这使得处理和验证这些等式更加一致和简单。
  2. 明确了每个选择器多项式的作用和系数，避免了正负号的混淆。
  3. 在验证过程中，统一的等式形式简化了对多项式的检查和验证。

非常简单是不是？很好，那么继续下一步。

第二步，根据已有的固定约束关系等式和三个转换后的等式，去判断选择器多项式的系数，这里我们可能会用到 0、1 和 -1 (系数 0 代表的是关闭状态，系数 1 和 -1 都表示开启状态)：

第一个门 `#1`:

如果 $x_3\cdot x_4 - x_6=0$ 要满足 $q_L \circ w_a + q_R \circ w_b + q_M\circ(w_a\cdot w_b) + q_C -  q_O\circ w_c = 0$ 这个固定等式关系，那么它的左输入选择器 $q_L=0$，它的右输入选择器 $q_R=0$，它的乘法选择器 $q_M=1$，常数选择器 $q_C=0$，输出选择器 $q_O=1$。

> 我们可以根据已有的约束关系判断对应选择器的具体数值（开关状态），我们也可以通过选择器的具体数值（开关状态）判断约束是否执行，二者可以互通有无。

我们可以对上面已经选择的选择器的值进行验证，如果将上面这些系数代入到 $q_L \circ w_a + q_R \circ w_b + q_M\circ(w_a\cdot w_b) + q_C -  q_O\circ w_c = 0$ 中进行验算，比如上面这个这些系数选择代入，我们就能得到 